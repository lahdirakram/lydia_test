"""this module contains a class that handles downoading, processing and saving data"""
import sqlite3

class DataHandler:
    """this class handles downoading, processing and saving data"""

    def __init__(self, database_path : str) -> None:
        # connecting to database 
        self.connection = sqlite3.connect(database_path)

    def download_data(self) -> list:
        """
        this method downloads data from premium_payments table takes a path to a sqlite database that contains a table named premium_payments
            :params
            path : string path to sqlite database
            :returns
            data : pythonlist with a tuple representing eah row in the table
        """
        # running sql select statement over premium_payments ordered by member_id and date_start
        iterable = self.connection.execute("""
            SELECT member_id, date(date_start) as date_start, date(date_end) as date_end, type 
            FROM premium_payments
            ORDER BY member_id, date_start
        """)
        # getting all data returned by the sql statement
        data = list(iterable)

        return data
    def process_data(self, data) -> list:
        """
        this method takes data fetched from premium_payments table and 
        creates a table that contains a row per subscription to premium 
        with the member_id, the type of the souscription (1 to 3)
        the starting date and the ending date.
            :params
            data : list of tuples generated by download_data
            :returns
            processed_data : list of tuples of  the new table like describes before
        """
        import pandas as pd
        from datetime import timedelta, datetime

        subscription_id = 0
        def subscription(row):
            nonlocal subscription_id
            if type(row["next_date_start"]) == str:
                next_date_start = datetime.strptime(row["next_date_start"],"%Y-%m-%d")
                date_end = datetime.strptime(row['date_end'],"%Y-%m-%d")
                if (next_date_start - date_end) <= timedelta(days=3):
                    if row['type'] == row['next_type']:
                        return subscription_id
   
            subscription_id +=1
            return (subscription_id-1)

        df=pd.DataFrame(
            data, 
            columns=("member_id","date_start","date_end","type")
            )
        df["next_date_start"] = df.groupby("member_id", as_index=False)["date_start"].shift(-1)
        df["next_type"] = df.groupby("member_id",as_index=False)["type"].shift(-1)
        df["subscription_id"] = df.apply(subscription,axis=1)

        processed_data = df\
            .groupby("subscription_id",as_index=False)\
                .agg({
                    'member_id':"first",
                    'date_start': "min", 
                    'date_end': "max",
                    'type': "first"
                })

        return processed_data[['member_id','date_start','date_end','type']].values.tolist()


    def save_data(self, table, processed_data, table_creation_sql=None) -> None:
        """
        this method inserts data into a sqlite database table
            :params
            path : string path to database file
            table : string table name of database table
            processed_data : python list of tuples returned by process_data
            table_creation_sql : table creatin sql statement if the table does not exist in database
        """

        if table_creation_sql is not None:
            # case of absence of table in data base
            # creating the table with creation statement specified in parameters
            self.connection.execute(table_creation_sql)

        # formating data for sql insertion
        str_values = str(processed_data[1:-1])
        # running sql insertion statement
        self.connection.execute(f"insert into {table} values {str_values}")
