"""this module contains a class that handles downoading, processing and saving data"""
import sqlite3
import pandas as pd
from datetime import timedelta, datetime

class DataHandler:
    """this class handles downoading, processing and saving data"""

    def __init__(self, database_path : str) -> None:
        # connecting to database 
        self.connection = sqlite3.connect(database_path)

    def download_data(self) -> list:
        """
        this method downloads data from premium_payments table
            :returns
            data : pythonlist with a tuple representing eah row in the table
        """
        # running sql select statement over premium_payments ordered by member_id and date_start
        cursor = self.connection.execute("""
            SELECT member_id, date(date_start) as date_start, date(date_end) as date_end, type 
            FROM premium_payments
            ORDER BY member_id, date_start
        """)
        # getting all data returned by the sql statement
        data = list(cursor)
        return data

    def process_data(self, data) -> list:
        """
        this method takes data fetched from premium_payments table and 
        creates a table that contains a row per subscription to premium 
        with the member_id, the type of the souscription (1 to 3)
        the starting date and the ending date.
            :params
            data : list of tuples generated by download_data
            :returns
            processed_data : list containing a row per subscription to premium
        """
        subscription_id = 0
        def subscription(row):
            """
            this function gives a subscription id to each row by calculating 
            the time difference between the end date and the  starting date 
            of the next payment, it also catches the change in type of subscription 
                :params
                row :  premium_payments like row with additional information like starting date 
                of the next payment and next type for the member.
                :returns
                a subscription id 
            """
            nonlocal subscription_id
            if type(row["next_date_start"]) == str:
                # converting date strings to datetime
                next_date_start = datetime.strptime(row["next_date_start"],"%Y-%m-%d")
                date_end = datetime.strptime(row['date_end'],"%Y-%m-%d")

                if (next_date_start - date_end) <= timedelta(days=3):
                    #if the difference is less then 3 days 
                    if row['type'] == row['next_type']:
                        # and there is no change in type 
                        # then its the same subscription as before 
                        return subscription_id
            # if any other case 
            # then the next subscription is not the same as now 
            # new id is given for it
            subscription_id +=1
            # and the previous id is returned for the last time
            return (subscription_id-1)

        df=pd.DataFrame(
            data, 
            columns=("member_id","date_start","date_end","type")
            )
        # shifting back the date_start and type for each member 
        # so that each row gets information about the next starting date end the next type
        df["next_date_start"] = df.groupby("member_id", as_index=False)["date_start"].shift(-1)
        df["next_type"] = df.groupby("member_id",as_index=False)["type"].shift(-1)

        # getting subscription id for each row
        df["subscription_id"] = df.apply(subscription,axis=1)

        # formating the table to get a row per subscription to premium
        processed_data = df\
            .groupby("subscription_id",as_index=False)\
                .agg({
                    'member_id':"first",
                    'date_start': "min", 
                    'date_end': "max",
                    'type': "first"
                })

        #selecting needed columns and returning them as list of rows
        return processed_data[['member_id','date_start','date_end','type']].values.tolist()


    def save_data(self, processed_data) -> None:
        """
        this method inserts data into a sqlite database table
            :params
            processed_data : python list of tuples returned by process_data
        """
        cur = self.connection.execute("""SELECT count(name) FROM sqlite_master WHERE type='table' AND name='subscriptions'""")
        if cur.fetchone()[0] == 0:
            # case of absence of table in data base
            # creating the table
            self.connection.execute("""CREATE TABLE subscriptions (member_id INTEGER, date_start TEXT, date_end TEXT, type INTEGER);""")

        # formating data for sql insertion
        str_values = str(processed_data)
        str_values = str_values[1:-1]
        str_values = str_values.replace('[','(')
        str_values = str_values.replace(']',')')
        
        # running sql insertion statement
        self.connection.execute(f"insert into subscriptions values {str_values}")
