"""this module contains a class that handles downoading, processing and saving data"""
import sqlite3
import datetime

class DataHandler:
    """this class handles downoading, processing and saving data"""

    def __init__(self, database_path : str) -> None:
        # connecting to database 
        self.connection = sqlite3.connect(database_path)

    def download_data(self) -> list:
        """
        this method downloads data from premium_payments table takes a path to a sqlite database that contains a table named premium_payments
            :params
            path : string path to sqlite database
            :returns
            data : pythonlist with a tuple representing eah row in the table
        """
        # running sql select statement over premium_payments ordered by member_id and date_start
        iterable = self.connection.execute("""
            SELECT member_id, date(date_start) as date_start, date(date_end) as date_end, type 
            FROM premium_payments
            ORDER BY member_id, date_start
        """)
        # getting all data returned by the sql statement
        data = list(iterable)

        return data

    def process_data(self, data) -> list:
        """
        this method takes data fetched from premium_payments table and 
        creates a table that contains a row per subscription to premium 
        with the member_id, the type of the souscription (1 to 3)
        the starting date and the ending date.
            :params
            data : list of tuples generated by download_data
            :returns
            processed_data : list of tuples of  the new table like describes before
        """
        # initializing variables
        member_id = date_start = date_end = type = None
        processed_data = []
        for row in data:
            # for each row in table
            if member_id is None:
                # case of first row
                member_id, date_start, date_end, type = row

            elif member_id != row[0]:
                # case of new member_id

                # inserting old row and creating new one
                processed_data.append((member_id, date_start, date_end, type))
                member_id, date_start, date_end, type = row

            elif type != row[3]:
                # case of new type

                # inserting old row and creating new one
                processed_data.append((member_id, date_start, date_end, type))
                _, date_start, date_end, type = row

            elif datetime.datetime.strptime(row[1],'%Y-%m-%d')\
                 - datetime.datetime.strptime(date_end,'%Y-%m-%d')\
                     < datetime.timedelta(3):
                # case of small time difference (<= 3 days) between old subscription and the new one
                # no row insertion but updating the end date of subscription
                date_end = row[2]
            else:
                # case of big difference (> 3 days) between old subscription and the new one
                # inserting old row and creating new one
                processed_data.append((member_id, date_start, date_end, type))
                _, date_start, date_end, type = row

        if not member_id == date_start == date_end == type == None:
            # finally inserting the last row if it exists
            processed_data.append((member_id, date_start, date_end, type))

        return processed_data

    def save_data(self, table, processed_data, table_creation_sql=None) -> None:
        """
        this method inserts data into a sqlite database table
            :params
            path : string path to database file
            table : string table name of database table
            processed_data : python list of tuples returned by process_data
            table_creation_sql : table creatin sql statement if the table does not exist in database
        """

        if table_creation_sql is not None:
            # case of absence of table in data base
            # creating the table with creation statement specified in parameters
            self.connection.execute(table_creation_sql)

        # formating data for sql insertion
        str_values = str(processed_data[1:-1])
        # running sql insertion statement
        self.connection.execute(f"insert into {table} values {str_values}")
